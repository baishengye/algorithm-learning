## 题目
你玩过`“拉灯”`游戏吗？

`25` 盏灯排成一个 `5×5` 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 `1` 表示一盏开着的灯，用数字 `0` 表示关着的灯。

下面这种状态
```c++
10111
01101
10111
10000
11011
```
在改变了最左上角的灯的状态后将变成：
```
01111
11101
10111
10000
11011
```
再改变它正中间的灯后状态将变成：
```c++
01111
11001
11001
10100
11011
```
给定一些游戏的初始状态，编写程序判断游戏者是否可能在 `6` 步以内使所有的灯都变亮。

## 输入格式
第一行输入正整数 `n`，代表数据中共有 `n` 个待解决的游戏初始状态。

以下若干行数据分为 `n` 组，每组数据有 `5` 行，每行 `5` 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

## 输出格式
一共输出 `n` 行数据，每行有一个小于等于 `6` 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 `6` 步以内无法使所有灯变亮，则输出 `−1`。

## 数据范围
$0<n≤500$

## 样例
```c++
输入样例：
3
00111
01011
10001
11010
11100

11101
11101
11110
11111
11111

01111
11111
11111
11111
11111
输出样例：

3
2
-1
```

## 分析
```c++
思路：我们枚举第一行的点击方法，共32种，完成第一行的点击后，固定第一行，
从第一行开始递推，若达到第n行不全为0，说明这种点击方式不合法。
在所有合法的点击方式中取点击次数最少的就是答案。
对第一行的32次枚举涵盖了该问题的整个状态空间，因此该做法是正确的

时间复杂度：32*20*5*500 = 一百六十万
对第一行操作有32种可能 * 对前四行有20种操作可能 * 每一次操作都要
改变5个灯的状态 * 最多读入的时候可能有500次light矩阵

最关键的两个性质
每一个位置最多只会被点击一次
如果固定了第一行，那么满足题意的点击方案最多只有一种
```


## 解答
```c++
#include <iostream>
#include <algorithm>
#include <cstring>

using namespace std;

const int N = 7;

char g[N][N],backup[N][N];//棋盘和备份
int dx[5] = {-1, 0, 1, 0, 0}, dy[5] = {0, 1, 0, -1, 0};//偏移矩阵

void turn(int x,int y)//变换(x,y)周围和自己的灯
{
    for (int i = 0; i < 5; i ++ )
    {
        int a = x + dx[i],b = y + dy[i];
        
        if(a < 0 || a > 4 || b < 0 || b > 4) continue;
        
        backup[a][b] ^= 1;
    }
}

int dfs()
{
    int res=10;
    
    for(int op=0;op<32;op++)//遍历第一行所有可能的开关方案
    {
        memcpy(backup,g,sizeof g);
        int step=0;
        
        for (int i = 0; i <5 ; i ++ )
            if(op>>i&1)
            {
                step++;
                turn(0,i);
            }
            
        //第一行的状态固定，那么后面行的状态也就固定了
        for (int i = 0; i < 4; i ++ )
            for (int j = 0; j < 5; j ++ )
                if(backup[i][j]=='0')
                {
                    step++;
                    turn(i+1,j);
                }
                
        //当所有行变换完了之后,如果最后一行能够全是1那么所有的灯就能全变成1
        bool dark=false;
        for (int i = 0; i < 5; i ++ )
            if(backup[4][i]=='0')
            {
                dark=true;
                break;
            }
            
        if(!dark) res=min(res,step);
    }
    
    if(res>6) res=-1;
    
    return res;
}

int main()
{
    int n;
    scanf("%d", &n);
    
    while (n -- )
    {
        for (int i = 0; i < 5; i ++ ) scanf("%s", g[i]);
        
        int res=dfs();
        
        printf("%d\n",res);
    }
    
    return 0;
}
```