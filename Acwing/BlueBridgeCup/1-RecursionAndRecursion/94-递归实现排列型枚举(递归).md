## 题目
把 $1∼n$ 这 $n$ 个整数排成一行后随机打乱顺序，输出所有可能的次序。

## 输入格式
一个整数 $n$。

输出格式
按照从小到大的顺序输出所有方案，每行 $1$ 个。

首先，同一行相邻两个数用一个空格隔开。

其次，对于两个不同的行，对应下标的数一一比较，字典序较小的排在前面。

## 数据范围
$1≤n≤9$

## 样例
```c++
输入样例：
3

输出样例：
1 2 3
1 3 2
2 1 3
2 3 1
3 1 2
3 2 1
```

## 分析
![](./../../pics/94.png)
```c++
算法：
用 path 数组保存排列，当排列的长度为 n 时，是一种方案，输出。
用 state 数组表示数字是否用过。当 state[i] 为 1 时：i 已经被用过，state[i] 为 0 时，i 没有被用过。
dfs(i) 表示的含义是：在 path[i] 处填写数字，然后递归的在下一个位置填写数字。
回溯：第 i 个位置填写某个数字的所有情况都遍历后， 第 i 个位置填写下一个数字。
```

## 解答
```c++
#include<iostream>

using namespace std;

const int N = 10;//最多一个数字序列有9个数字

int w[N];//排列方案
bool st[N];//数字是否使用过
int n;

void dfs(int u)
{
    if(u==n+1)//如果序列已经填充了n位就可以打印序列并且结束
    {
        for (int i = 1; i <= n; i ++ ) printf("%d ",w[i]);
        puts("");
        return;
    }
    
    for (int i = 1; i <= n; i ++ )//尝试往序列的第u位填充还没使用过的数字
        if(!st[i])
        {
            st[i]=true;
            w[u]=i;//往第u个空位填充i
            dfs(u+1);
            
            //恢复现场
            st[i]=false;
            w[u]=0;
        }
}

int main()
{
    scanf("%d", &n);
    dfs(1);//从序列的第一位开始填充
    
    return 0;
}
```