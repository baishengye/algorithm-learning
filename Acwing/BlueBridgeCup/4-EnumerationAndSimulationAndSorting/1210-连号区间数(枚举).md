## 题目
小明这些天一直在思考这样一个奇怪而有趣的问题：

在 `1∼N` 的某个排列中有多少个连号区间呢？

这里所说的连号区间的定义是：

如果区间 `[L,R]` 里的所有元素（即此排列的第 `L` 个到第 `R` 个元素）递增排序后能得到一个长度为 `R−L+1` 的“连续”数列，则称这个区间连号区间。

当 `N` 很小的时候，小明可以很快地算出答案，但是当 `N` 变大的时候，问题就不是那么简单了，现在小明需要你的帮助。

## 输入格式
第一行是一个正整数 `N`，表示排列的规模。

第二行是 `N` 个不同的数字 $P_i$，表示这 `N` 个数字的某一排列。

## 输出格式
输出一个整数，表示不同连号区间的数目。

## 数据范围
$1≤N≤10000,$
$1≤P_i≤N$

## 样例
```c++
输入样例1：
4
3 2 4 1
输出样例1：
7
输入样例2：
5
3 4 2 5 1
输出样例2：
9
样例解释
第一个用例中，有 7 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[2,2],[3,3],[4,4]
第二个用例中，有 9 个连号区间分别是：[1,1],[1,2],[1,3],[1,4],[1,5],[2,2],[3,3],[4,4],[5,5]
```

## 分析
### 算法分析
1. 固定`L`，遍历`R`
2. 在`[L,R]`区域中找到最大值`Max`，最小值`Min`，若`maxv - minv == j - i`，则说明该区域`[L,R]`是递增且连续的
3. 如何找到`maxv`和`minv`呢？不用每次都重新在`[L,R]`之间找最大值和最小值,`[L,i...R]`之间`R`依次增加`1`的时候，我们只需要比较新出现的一个数和原来的最小值或最大值

### 时间复杂度 O(n2)

## 解答
```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 10010;

int p[N];
int n;

int main()
{
    scanf("%d", &n);
    for (int i = 1; i <= n; i ++ )
        scanf("%d",&p[i]);
        
    int ans=0;
    for (int i = 1; i <= n; i ++ ){//L从1开始枚举
        int Min=0x3f3f3f3f,Max=-1;
        for (int j = i; j <= n; j ++ )
        //不用每次都重新在[L,R]之间找最大值和最小值,[L,i...R]之间R依次增加1的时候，
        //我们只需要比较新出现的一个数和原来的最小值或最大值
        {
            Min=min(Min,p[j]);
            Max=max(Max,p[j]);
            
            if(j-i==Max-Min) 
                ans++;
        }
    }
    
    printf("%d",ans);
    
    return 0;
}
```