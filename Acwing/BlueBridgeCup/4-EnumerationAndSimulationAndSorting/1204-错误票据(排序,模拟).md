## 题目
某涉密单位下发了某种票据，并要在年终全部收回。

每张票据有唯一的`ID`号。

全年所有票据的`ID`号是连续的，但`ID`的开始数码是随机选定的。

因为工作人员疏忽，在录入`ID`号的时候发生了一处错误，造成了某个`ID`断号，另外一个`ID`重号。

你的任务是通过编程，找出断号的`ID`和重号的`ID`。

假设断号不可能发生在最大和最小号。

## 输入格式
第一行包含整数 `N`，表示后面共有 `N` 行数据。

接下来 `N` 行，每行包含空格分开的若干个（不大于`100`个）正整数（不大于`100000`），每个整数代表一个`ID`号。

## 输出格式
要求程序输出`1`行，含两个整数 `m,n`，用空格分隔。

其中，`m`表示断号`ID`，`n`表示重号`ID`。

## 数据范围
$1≤N≤100$

## 样例
```c++
输入样例：
2
5 6 8 11 9 
10 12 9
输出样例：
7 9
```

## 分析
```c++
先排序,排完序之后重复的数一定相邻
出现断层的地方就是断号了
```

## 解答
```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010;

int d[N];

int main()
{
    int n;
    cin>>n;
    
    int k=0;
    while(cin>>d[k++])
    
    sort(d,d+k);
    
    int u,v;//u断号,v重号
    for(int i=1;i<k;i++)
    {
        if(d[i]-2==d[i-1]) u=d[i]-1;
        else if(d[i-1]==d[i]) v=d[i];
    }
    
    printf("%d %d",u,v);
    return 0;
}
```