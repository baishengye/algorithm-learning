## 题目
给定 `N` 个加号、`M` 个减号以及` N+M+1` 个整数 $A_1,A_2,⋅⋅⋅,A_{N+M+1}$，小明想知道在所有由这 `N` 个加号、`M` 个减号以及 `N+M+1` 个整数凑出的合法的后缀表达式中，结果最大的是哪一个？

请你输出这个最大的结果。

例如使用 `123+−`，则 `“23+1−”` 这个后缀表达式结果是 `4`，是最大的。

## 输入格式
第一行包含两个整数 N 和 M。

第二行包含 N+M+1 个整数 A1,A2,⋅⋅⋅,AN+M+1。

## 输出格式
输出一个整数，代表答案。

## 数据范围
$0≤N,M≤105,$
$−10^9≤A_i≤10^9$

## 样例
```c++
输入样例：
1 1
1 2 3
输出样例：
4
```

## 分析
给题意翻译翻译，其实就是有n个加号，m个减号，n+m+1个数，可以加括号，问组成表达式的最大值。
特殊情况：m=0，直接输出和
一般情况：把所有数排个序，最大的拿出来，放首项，把最小的数拿出来，给他一个减号，再套一个括号，那么现在还未完成的表达式长这样：

可以发现，现在如果我想加一个数的话，给它一个加号，放在括号外面，也可以给它一个减号，放在括号里面；减一个数同理。换句话说，只要用一个减号，一个最大值，一个最小值，其他数我想加就加，想减就减。那么为了使结果最大，我加上正数，减去负数，就是直接加上所有剩下数的绝对值，那么就解决了。

## 解答
```c++
/*
后缀表达式也叫逆波兰表达式
比如:23+1−
就是数字就存到栈里，符号就对应计算
对应这个式子就是: 2入栈,3入栈，符号为+，把2和3取出来,2+3=5入栈,1入栈，符号为-，取出5和1，得5-1=4
就是最大是2+3-1=4

所有的逆波兰表达式都可以转化成一个树(内部节点是+和-，叶子节点是数字)
树的后序遍历就是这个表达式
*/

#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN=1e5+10;
int n,m,k;
LL a[2*MAXN];

int main(){
    scanf("%d%d",&n,&m);
    k=n+m+1;
    for(int i=1;i<=k;i++) scanf("%lld",&a[i]);
    LL sum=0;
    if(!m){
        for(int i=1;i<=k;i++) sum+=a[i];
        printf("%lld\n",sum);
        return 0;
    }
    sort(a+1,a+k+1);
    sum+=a[k];sum-=a[1];m--; 
    for(int i=2;i<k;i++) sum+=abs(a[i]);
    printf("%lld\n",sum);
    return 0;
}
```