## 题目
给定 `N` 个整数` A1,A2,…AN`。

请你从中选出 `K` 个数，使其乘积最大。

请你求出最大的乘积，由于乘积可能超出整型范围，你只需输出乘积除以 `1000000009` 的余数。

注意，如果 `X<0`， 我们定义 `X` 除以 `1000000009` 的余数是负(`−X`)除以 `1000000009` 的余数，即：`0−((0−x)%1000000009)`

## 输入格式
第一行包含两个整数 `N 和 K`。

以下 `N `行每行一个整数 `Ai`。

## 输出格式
输出一个整数，表示答案。

## 数据范围
$1≤K≤N≤10^5,$
$−10^5≤A_i≤10^5$

## 样例
```c++
输入样例1：
5 3
-100000
-10000
2
100000
10000
输出样例1：
999100009
输入样例2：
5 3
-100000
-100000
-2
-100000
-100000
输出样例2：
-999999829
```

## 解答
```c++
/*
该题的题解是整理了一下 y总视频里面讲解思路,希望对看完视频还不大理解的同学有点帮助
首先我们知道 如果 k == n ,那么就证明所有的数字是全部都选,
             如果 k < n , 那么就要思考怎样去选择了:
1.k 如果是偶数的话,选出来的结果一定是非负数 , 原因如下:
             (1) # 负数的个数是偶数个的话,负负得正,那么一定是非负数
             (2) # 负数的个数如果是奇数个的话,那么我们就只选偶数个绝对值最大的负数
2.k 如果是奇数个的话,
             (1)# 所有的数字如果都是负数,那么选出来的结果也一定都是负数    
             (2)# 否则的话,则一定至少有 1个非负数, 那么我们将最大的数取出来, 此时要选的个数就是 k--, 
                # k-- 是偶数,那么就又转化为 k-- 是偶数的情况思考
*/

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

typedef long long LL;

const int N = 1e5+10,mod=1000000009;

int n,k;
int a[N];

int main()
{
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i ++ ) scanf("%d", &a[i]);
    
    sort(a,a+n);
    
    int res=1;
    int l=0,r=n-1;
    int sign=1;
    if(k%2){
        res=a[r--];
        k--;
        if(res<0) sign=-1;
    }
    
    while(k){
        LL x=(LL)a[l]*a[l+1],y=(LL)a[r-1]*a[r];
        if(x*sign>y*sign){
            res=x%mod*res%mod;
            l+=2;
        }else{
            res=y%mod*res%mod;
            r-=2;
        }
        k-=2;
    }
    printf("%d\n",res);
    return 0;
}
```