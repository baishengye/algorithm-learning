## 题目
天空中有一些星星，这些星星都在不同的位置，每个星星有个坐标。

如果一个星星的左下方（包含正左和正下）有 `k` 颗星星，就说这颗星星是 `k` 级的。

![](../../pics/1265.png)

例如，上图中星星 `5` 是 `3` 级的（`1,2,4` 在它左下），星星 `2,4` 是 `1` 级的。

例图中有 `1` 个 `0` 级，`2 `个 `1` 级，`1` 个 `2` 级，`1` 个 `3` 级的星星。

给定星星的位置，输出各级星星的数目。

换句话说，给定 `N` 个点，定义每个点的等级是在该点左下方（含正左、正下）的点的数目，试统计每个等级有多少个点。

## 输入格式
第一行一个整数 `N`，表示星星的数目；

接下来 N 行给出每颗星星的坐标，坐标用两个整数 `x,y` 表示；

不会有星星重叠。星星按 `y` 坐标增序给出，y 坐标相同的按 `x` 坐标增序给出。

## 输出格式
`N` 行，每行一个整数，分别是 `0 `级，`1` 级，`2` 级，`……`，`N−1` 级的星星的数目。

## 数据范围
$1≤N≤15000,$
$0≤x,y≤32000$

## 样例
```c++
输入样例：
5
1 1
5 1
7 1
3 3
5 5
输出样例：
1
2
1
1
0
```

## 分析

## 解答
```c++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 320010;//要取到所有坐标

int tr[N],ans[N];
int n;

int lowbit(int x)//比如lowbit(6)->2
{
    return x&-x;
}

void add(int u,int v)
{
    for (int i = u; i <= N; i += lowbit(i))//i实际上对应的是坐标x,所以i应该取到x的范围
        tr[i]+=v;
}

int query(int u)
{
    int res=0;
    for (int i = u; i ; i -= lowbit(i))
        res+=tr[i];
    return res;
}

int main()
{
    scanf("%d", &n);
    
    for (int i = 1; i <= n; i ++ )
    {
        int x,y;
        scanf("%d%d", &x, &y);
        
        x++;//lowbit()求出来的2^k一定是>=1的,但是x是可能为0的，所以为了避免这种情况，我们把所有x都+1,就既不会产生影响,lowbit()也一定能求到所有x
        add(x, 1);//横坐标是x的坐标+1
        ans[query(x)]++;//由于输入的数据y是非严格单调递增的，所以后面的坐标y一定不会阻止等级升高,所以判断等级升不升的关键在于x
    }
    
    for (int i = 1; i <= n; i ++ )
        printf("%d\n",ans[i]);
        
    return 0;
}
```