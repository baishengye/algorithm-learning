## **题目描述**

给定一个长度为n的字符串，再给定m个询问，每个询问包含四个整数l1,r1,l2,r2，请你判断[l1,r1]和[l2,r2]这两个区间所包含的字符串子串是否完全相同。

字符串中只包含大小写英文字母和数字。

## **输入格式**

第一行包含整数n和m，表示字符串长度和询问次数。

第二行包含一个长度为n的字符串，字符串中只包含大小写英文字母和数字。

接下来m行，每行包含四个整数l1,r1,l2,r2，表示一次询问所涉及的两个区间。

注意，字符串的位置从1开始编号。

## **输出格式**

对于每个询问输出一个结果，如果两个字符串子串完全相同则输出“Yes”，否则输出“No”。

每个结果占一行。

## **数据范围**

$1≤n,m≤10^5$

## **输入样例**
```c++
8 3
aabbaabb
1 3 5 7
1 3 6 8
1 2 1 2
```

## **输出样例**
```c++
Yes
No
Yes
```
## **分析**
(字符串哈希) $O(n)+O(m)$
全称字符串前缀哈希法，把字符串变成一个p进制数字（哈希值），实现不同的字符串映射到不同的数字。

对形如 $X_1X_2X_3⋯X_{n−1}X_n$的字符串,采用字符的ascii 码乘上 P 的次方来计算哈希值。

映射公式 $(X_1×P_{n−1}+X_2×P_{n−2}+⋯+X_{n−1}×P_1+X_n×P_0)modQ$

注意点：
1. 任意字符不可以映射成0，否则会出现不同的字符串都映射成0的情况，比如A,AA,AAA皆为0
2. 冲突问题：通过巧妙设置P (131 或 13331) , Q ($2^{64}$)的值，一般可以理解为不产生冲突,而且$2^{64}$溢出值就相当于mod了。

问题是比较不同区间的子串是否相同，就转化为对应的哈希值是否相同。
求一个字符串的哈希值就相当于求前缀和，求一个字符串的子串哈希值就相当于求部分和。

前缀和公式 h[i+1]=h[i]×P+s[i]h[i+1]=h[i]×P+s[i] i∈[0,n−1]i∈[0,n−1] h为前缀和数组，s为字符串数组
区间和公式 h[l,r]=h[r]−h[l−1]×Pr−l+1h[l,r]=h[r]−h[l−1]×P[r−l+1]
区间和公式的理解: ABCDE 与 ABC 的前三个字符值是一样，只差两位，
乘上 $P_2$ 把 ABC 变为 ABC00，再用 ABCDE - ABC00 得到 DE 的哈希值。

## **解答**
```c++
#include "bits/stdc++.h"

using namespace std;

typedef unsigned long long ULL;

const int N=1e5+10;

char str[N];
ULL h[N],p[N],P=131;

ULL get(int l,int r){
    return h[r]-h[l-1]*p[r-l+1];
}

int main(){
    int n,m;
    scanf("%d%d",&n,&m);
    scanf("%s",str);

    p[0]=1;
    for(int i=1;i<=n;i++){
         p[i]=p[i-1]*P;
         h[i]=h[i-1]*P+str[i];   
    }

    int l1,r1,l2,r2;
    while (m--)
    {
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        if(get(l1,r1)==get(l2,r2)) printf("Yes");
        else printf("No");
    }

    return 0;
}
```