## **题目**
在著名的快速排序中，有一个经典的过程叫做划分。

在此过程中，我们通常选取其中一个元素作为分界值。

将小于分界值的元素移到其左侧，将大于分界值的元素移到其右侧。

给定 N 个不同的正整数进行过一次划分后的排列情况。

请你判断，共有多少元素可能是此次划分的分界值。

例如，N=5，各元素排列为 1,3,2,4,5，则：

- 1 可能是分界值，因为它的左侧没有元素，而右侧的元素都比它大。
- 3 一定不是分界值，因为尽管它的左侧的元素都比它小，但是它右侧的 2 也小于它。
- 2 一定不是分界值，因为尽管它的右侧的元素都比它大，但是它左侧的 3 也大于它。
- 出于类似判断可知 4,5 也可能是分界值。
- 因此，在此样例中，共有 3 个可能的分界值。

## **输入格式**
第一行包含整数 N。

第二行包含 N 个不同的正整数。

## **输出格式**
第一行输出可能的分界值数量。

第二行按升序顺序输出所有可能的分界值。

如果分界值数量为 0，则在输出分界值数量后，输出一个空行即可。

## **数据范围**
```c++
1≤N≤105,
1≤ 给定元素 ≤109。
```

## **输入样例**
```c++
5
1 3 2 4 5
```

## **输出样例**
```c++
3
1 4 5
```

## **分析**
只有比左边大且比右边小的数能成为边界，所有可以利用动态规划把每个下标对应的左侧最大值和右侧最小值存下来，然后再比较得出结果

## **解答**
```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <climits>

using namespace std;

const int N = 1e5+10;

int a[N],dpMax[N],dpMin[N],r[N];

int main()
{
    int n;
    scanf("%d", &n);
    
    for(int i=1;i<=n;i++)
        scanf("%d",a+i);
        
    dpMax[0]=INT_MIN;
    for (int i = 1; i <= n; i ++ )
        dpMax[i]=max(dpMax[i-1],a[i]);
    
    dpMin[n+1]=INT_MAX;
    for(int i=n;i>=1;i--)
        dpMin[i]=min(dpMin[i+1],a[i]);
        
    int k=0;
    for(int i=1;i<=n;i++){
        if(a[i]>=dpMax[i-1]&&a[i]<=dpMin[i+1]) r[k++]=a[i];
    }
    
    printf("%d\n",k);
    for(int i=0;i<k;i++)
        printf("%d ",r[i]);
    
    printf("\n");
        
    return 0;
}
```