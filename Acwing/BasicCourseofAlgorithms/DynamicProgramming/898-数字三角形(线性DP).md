## 题目
给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。
```c++
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

## 输入格式
第一行包含整数 n，表示数字三角形的层数。

接下来 n 行，每行包含若干整数，其中第 i 行表示数字三角形第 i 层包含的整数。

## 输出格式
输出一个整数，表示最大的路径数字和。

## 数据范围
$1≤n≤500,$
$−10000≤三角形中的整数≤10000$

## 样例
```c++
输入样例：
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
输出样例：
30
```

## 分析
```c++
DP:
    状态表示:f[i][j]
        集合:到达(i,j)这个坐标的路径上的数字和的最大值
        属性:max
    状态计算:
        f[i][j]=max(f[i-1][j-1]+a[i][j],f[i-1][j]+a[i][j]);
```

## 解答
```c++

#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 510,INF=1e9;

int a[N][N];
int f[N][N];
int n;

int main()
{
    cin>>n;
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= i; j ++ )
            cin>>a[i][j];
    
    for (int i = 1; i <= n; i ++ )
    //第一行的数上面没有，那么第一行第一个的路径和就是自己,
    //所以第0行不用初始化(其实是初始化成0)
        for (int j = 0; j <= i+1; j ++ )
        //在第i行去取上一行的时候回去到左上或者右上没有数的位置
        //这个时候为了不让这种位置被取到,就把这种位置的路径和设
        //为-INF,那么就会在max()的时候舍弃这种位置
            f[i][j]=-INF;
            
    for (int i = 1; i <= n; i ++ )
        for (int j = 1; j <= i; j ++ )
            f[i][j]=max(f[i-1][j],f[i-1][j-1])+a[i][j];
    
    int ans=-INF;
    for(int i=1;i<=n;i++)
        ans=max(ans,f[n][i]);
        
    cout<<ans<<endl;
    
    return 0;
}
```