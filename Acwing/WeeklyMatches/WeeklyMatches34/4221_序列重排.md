## **题目**
给定一个长度为 n 的整数序列 a1,a2,…,an。

请你对序列进行重新排序（也可以保持原序列），要求新序列满足每个元素（第 1 个除外）都恰好是前一个元素的两倍或前一个元素的三分之一。

保证输入一定有解。

## **输入格式**
第一行包含整数 n。

第二行包含 n 个整数 a1,a2,…,an。

## **输出格式**
一行 n 个整数，表示排序后的序列。输出任意合法方案即可。

## **数据范围**
前三个测试点满足 $2≤n≤10。$

所有测试点满足 $2≤n≤100，1≤a_i≤3×10^{18}$。

## **输入样例1**
```c++
6
4 8 6 3 12 9
```

## **输出样例1**
```c++
9 3 6 12 4 8
```

## **输入样例2**
```c++
4
42 28 84 126
```

## **输出样例2**
```c++
126 42 84 28
```

## **输入样例3**
```c++
2
1000000000000000000 3000000000000000000
```

## **输出样例3**
```c++
3000000000000000000 1000000000000000000
```

## **分析**
（1）必要性：由于这道题保障一定有解，我们可以倒推这样的序列满足的性质。题中给的条件是a[i] == a[i - 1] * 2或a[i] * 3 == a[i - 1]，所以这样的序列可以是按照包含2或者3的因子个数排列的，实际上，q[i] = {get(x, 2), -get(x, 3), x}还可以写成q[i] = {-get(x, 3), get(x, 2), x}。

（2）同时从（1）还可以推出满足条件的序列是唯一的（反证法）；

（3）充分性（也是这道题最巧妙的一环）：假设任取一个可行的序列，那么一定满足我们前面的性质，即a[i] == a[i - 1] * 2或a[i] * 3 == a[i - 1]，又因为满足该性质的序列是唯一的，所以这个任取一个可行的序列就是唯一的。

（4）综上所述，实际上题里声称的”输出任意合法方案即可“是虚晃一枪

## **y总的解答，自己搞不倒**
```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>

using namespace std;

typedef long long LL;

const int N = 110;

int n;
vector<LL> q[N];

int get(LL x, int b)
{
    int res = 0;
    while (x % b == 0) res ++, x /= b;
    return res;
}

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++ )
    {
        LL x;
        cin >> x;
        q[i] = {get(x, 2), -get(x, 3), x};//这个地方很有疑问
    }

    sort(q, q + n);//排序，按照关键字排序

    for (int i = 0; i < n; i ++ )
        cout << q[i][2] << ' ';
    cout << endl;

    return 0;
}
```